/**
 * Deep Thought Administration API
 * This is the Deep Thought Administration API. You can find out more about Deep Thought at [https://github.com/bizaio/deepthought](https://github.com/bizaio/deepthought) or on the [DataRight.io Slack, #oss](https://join.slack.com/t/datarightio/shared_invite/enQtNzAyNTI2MjA2MzU1LTU1NGE4MmQ2N2JiZWI2ODA5MTQ2N2Q0NTRmYmM0OWRlM2U5YzA3NzU5NDYyODlhNjRmNzU3ZDZmNTI0MDE3NjY).
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { DioProduct } from '../model/dioProduct';
import { DioProductBundle } from '../model/dioProductBundle';
import { DioProductConstraint } from '../model/dioProductConstraint';
import { DioProductEligibility } from '../model/dioProductEligibility';
import { DioProductFeature } from '../model/dioProductFeature';
import { DioProductFee } from '../model/dioProductFee';
import { DioProductRateDeposit } from '../model/dioProductRateDeposit';
import { DioProductRateLending } from '../model/dioProductRateLending';
import { ValidationListException } from '../model/validationListException';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ProductAdminService {

    protected basePath = 'http://localhost:8080/dio-au';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Create a Product
     * Creates and Returns a new Product
     * @param brandId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProduct(brandId: string, body?: DioProduct, observe?: 'body', reportProgress?: boolean): Observable<DioProduct>;
    public createProduct(brandId: string, body?: DioProduct, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProduct>>;
    public createProduct(brandId: string, body?: DioProduct, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProduct>>;
    public createProduct(brandId: string, body?: DioProduct, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling createProduct.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProduct>('post',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Product Constraint
     * Creates and Returns a new Product Constraint
     * @param brandId 
     * @param productId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProductConstraint(brandId: string, productId: string, body?: DioProductConstraint, observe?: 'body', reportProgress?: boolean): Observable<DioProductConstraint>;
    public createProductConstraint(brandId: string, productId: string, body?: DioProductConstraint, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductConstraint>>;
    public createProductConstraint(brandId: string, productId: string, body?: DioProductConstraint, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductConstraint>>;
    public createProductConstraint(brandId: string, productId: string, body?: DioProductConstraint, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling createProductConstraint.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling createProductConstraint.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProductConstraint>('post',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/constraint`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Product Eligibility
     * Creates and Returns a new Product Eligibility
     * @param brandId 
     * @param productId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProductEligibility(brandId: string, productId: string, body?: DioProductEligibility, observe?: 'body', reportProgress?: boolean): Observable<DioProductEligibility>;
    public createProductEligibility(brandId: string, productId: string, body?: DioProductEligibility, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductEligibility>>;
    public createProductEligibility(brandId: string, productId: string, body?: DioProductEligibility, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductEligibility>>;
    public createProductEligibility(brandId: string, productId: string, body?: DioProductEligibility, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling createProductEligibility.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling createProductEligibility.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProductEligibility>('post',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/eligibility`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Product Feature
     * Creates and Returns a new Product Feature
     * @param brandId 
     * @param productId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProductFeature(brandId: string, productId: string, body?: DioProductFeature, observe?: 'body', reportProgress?: boolean): Observable<DioProductFeature>;
    public createProductFeature(brandId: string, productId: string, body?: DioProductFeature, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductFeature>>;
    public createProductFeature(brandId: string, productId: string, body?: DioProductFeature, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductFeature>>;
    public createProductFeature(brandId: string, productId: string, body?: DioProductFeature, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling createProductFeature.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling createProductFeature.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProductFeature>('post',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/feature`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Product Fee
     * Creates and Returns a new Product Fee
     * @param brandId 
     * @param productId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProductFee(brandId: string, productId: string, body?: DioProductFee, observe?: 'body', reportProgress?: boolean): Observable<DioProductFee>;
    public createProductFee(brandId: string, productId: string, body?: DioProductFee, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductFee>>;
    public createProductFee(brandId: string, productId: string, body?: DioProductFee, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductFee>>;
    public createProductFee(brandId: string, productId: string, body?: DioProductFee, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling createProductFee.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling createProductFee.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProductFee>('post',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/fee`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Product Deposit Rate
     * Creates and Returns a new Product Deposit Rate
     * @param brandId 
     * @param productId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProductRateDeposit(brandId: string, productId: string, body?: DioProductRateDeposit, observe?: 'body', reportProgress?: boolean): Observable<DioProductRateDeposit>;
    public createProductRateDeposit(brandId: string, productId: string, body?: DioProductRateDeposit, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductRateDeposit>>;
    public createProductRateDeposit(brandId: string, productId: string, body?: DioProductRateDeposit, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductRateDeposit>>;
    public createProductRateDeposit(brandId: string, productId: string, body?: DioProductRateDeposit, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling createProductRateDeposit.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling createProductRateDeposit.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProductRateDeposit>('post',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/deposit-rate`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Product Lending Rate
     * Creates and Returns a new Product Lending Rate
     * @param brandId 
     * @param productId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProductRateLending(brandId: string, productId: string, body?: DioProductRateLending, observe?: 'body', reportProgress?: boolean): Observable<DioProductRateLending>;
    public createProductRateLending(brandId: string, productId: string, body?: DioProductRateLending, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductRateLending>>;
    public createProductRateLending(brandId: string, productId: string, body?: DioProductRateLending, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductRateLending>>;
    public createProductRateLending(brandId: string, productId: string, body?: DioProductRateLending, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling createProductRateLending.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling createProductRateLending.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProductRateLending>('post',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/lending-rate`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a single Product
     * Deletes a Product
     * @param brandId 
     * @param productId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProduct(brandId: string, productId: string, observe?: 'body', reportProgress?: boolean): Observable<DioProduct>;
    public deleteProduct(brandId: string, productId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProduct>>;
    public deleteProduct(brandId: string, productId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProduct>>;
    public deleteProduct(brandId: string, productId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling deleteProduct.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling deleteProduct.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<DioProduct>('delete',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a single Product Constraint
     * Deletes a Product Constraint
     * @param brandId 
     * @param productId 
     * @param constraintId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductConstraint(brandId: string, productId: string, constraintId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProductConstraint(brandId: string, productId: string, constraintId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProductConstraint(brandId: string, productId: string, constraintId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProductConstraint(brandId: string, productId: string, constraintId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling deleteProductConstraint.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling deleteProductConstraint.');
        }

        if (constraintId === null || constraintId === undefined) {
            throw new Error('Required parameter constraintId was null or undefined when calling deleteProductConstraint.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/constraint/${encodeURIComponent(String(constraintId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a single Product Eligibility
     * Deletes a Product Eligibility
     * @param brandId 
     * @param productId 
     * @param eligibilityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductEligibility(brandId: string, productId: string, eligibilityId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProductEligibility(brandId: string, productId: string, eligibilityId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProductEligibility(brandId: string, productId: string, eligibilityId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProductEligibility(brandId: string, productId: string, eligibilityId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling deleteProductEligibility.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling deleteProductEligibility.');
        }

        if (eligibilityId === null || eligibilityId === undefined) {
            throw new Error('Required parameter eligibilityId was null or undefined when calling deleteProductEligibility.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/eligibility/${encodeURIComponent(String(eligibilityId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a single Product Feature
     * Deletes a Product Feature
     * @param brandId 
     * @param productId 
     * @param featureId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductFeature(brandId: string, productId: string, featureId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProductFeature(brandId: string, productId: string, featureId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProductFeature(brandId: string, productId: string, featureId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProductFeature(brandId: string, productId: string, featureId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling deleteProductFeature.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling deleteProductFeature.');
        }

        if (featureId === null || featureId === undefined) {
            throw new Error('Required parameter featureId was null or undefined when calling deleteProductFeature.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/feature/${encodeURIComponent(String(featureId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a single Product Fee
     * Deletes a Product Fee
     * @param brandId 
     * @param productId 
     * @param feeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductFee(brandId: string, productId: string, feeId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProductFee(brandId: string, productId: string, feeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProductFee(brandId: string, productId: string, feeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProductFee(brandId: string, productId: string, feeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling deleteProductFee.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling deleteProductFee.');
        }

        if (feeId === null || feeId === undefined) {
            throw new Error('Required parameter feeId was null or undefined when calling deleteProductFee.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/fee/${encodeURIComponent(String(feeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a single Product Deposit Rate
     * Deletes a Product Deposit Rate
     * @param brandId 
     * @param productId 
     * @param rateId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductRateDeposit(brandId: string, productId: string, rateId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProductRateDeposit(brandId: string, productId: string, rateId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProductRateDeposit(brandId: string, productId: string, rateId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProductRateDeposit(brandId: string, productId: string, rateId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling deleteProductRateDeposit.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling deleteProductRateDeposit.');
        }

        if (rateId === null || rateId === undefined) {
            throw new Error('Required parameter rateId was null or undefined when calling deleteProductRateDeposit.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/deposit-rate/${encodeURIComponent(String(rateId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a single Product Lending Rate
     * Deletes a Product Lending Rate
     * @param brandId 
     * @param productId 
     * @param rateId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductRateLending(brandId: string, productId: string, rateId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProductRateLending(brandId: string, productId: string, rateId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProductRateLending(brandId: string, productId: string, rateId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProductRateLending(brandId: string, productId: string, rateId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling deleteProductRateLending.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling deleteProductRateLending.');
        }

        if (rateId === null || rateId === undefined) {
            throw new Error('Required parameter rateId was null or undefined when calling deleteProductRateLending.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/lending-rate/${encodeURIComponent(String(rateId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a single Product
     * Returns a single product entry
     * @param brandId 
     * @param productId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProduct(brandId: string, productId: string, observe?: 'body', reportProgress?: boolean): Observable<DioProduct>;
    public getProduct(brandId: string, productId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProduct>>;
    public getProduct(brandId: string, productId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProduct>>;
    public getProduct(brandId: string, productId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling getProduct.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getProduct.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<DioProduct>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a single Product Constraint
     * Returns a single product constraint entry
     * @param brandId 
     * @param productId 
     * @param constraintId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductConstraint(brandId: string, productId: string, constraintId: string, observe?: 'body', reportProgress?: boolean): Observable<DioProductConstraint>;
    public getProductConstraint(brandId: string, productId: string, constraintId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductConstraint>>;
    public getProductConstraint(brandId: string, productId: string, constraintId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductConstraint>>;
    public getProductConstraint(brandId: string, productId: string, constraintId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling getProductConstraint.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getProductConstraint.');
        }

        if (constraintId === null || constraintId === undefined) {
            throw new Error('Required parameter constraintId was null or undefined when calling getProductConstraint.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<DioProductConstraint>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/constraint/${encodeURIComponent(String(constraintId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a single Product Eligibility
     * Returns a single product eligibility entry
     * @param brandId 
     * @param productId 
     * @param eligibilityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductEligibility(brandId: string, productId: string, eligibilityId: string, observe?: 'body', reportProgress?: boolean): Observable<DioProductEligibility>;
    public getProductEligibility(brandId: string, productId: string, eligibilityId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductEligibility>>;
    public getProductEligibility(brandId: string, productId: string, eligibilityId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductEligibility>>;
    public getProductEligibility(brandId: string, productId: string, eligibilityId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling getProductEligibility.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getProductEligibility.');
        }

        if (eligibilityId === null || eligibilityId === undefined) {
            throw new Error('Required parameter eligibilityId was null or undefined when calling getProductEligibility.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<DioProductEligibility>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/eligibility/${encodeURIComponent(String(eligibilityId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a single Product Feature
     * Returns a single product feature entry
     * @param brandId 
     * @param productId 
     * @param featureId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductFeature(brandId: string, productId: string, featureId: string, observe?: 'body', reportProgress?: boolean): Observable<DioProductFeature>;
    public getProductFeature(brandId: string, productId: string, featureId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductFeature>>;
    public getProductFeature(brandId: string, productId: string, featureId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductFeature>>;
    public getProductFeature(brandId: string, productId: string, featureId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling getProductFeature.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getProductFeature.');
        }

        if (featureId === null || featureId === undefined) {
            throw new Error('Required parameter featureId was null or undefined when calling getProductFeature.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<DioProductFeature>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/feature/${encodeURIComponent(String(featureId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a single Product Fee
     * Returns a single product fee entry
     * @param brandId 
     * @param productId 
     * @param feeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductFee(brandId: string, productId: string, feeId: string, observe?: 'body', reportProgress?: boolean): Observable<DioProductFee>;
    public getProductFee(brandId: string, productId: string, feeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductFee>>;
    public getProductFee(brandId: string, productId: string, feeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductFee>>;
    public getProductFee(brandId: string, productId: string, feeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling getProductFee.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getProductFee.');
        }

        if (feeId === null || feeId === undefined) {
            throw new Error('Required parameter feeId was null or undefined when calling getProductFee.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<DioProductFee>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/fee/${encodeURIComponent(String(feeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a single Product Deposit Rate
     * Returns a single product rate entry
     * @param brandId 
     * @param productId 
     * @param rateId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductRateDeposit(brandId: string, productId: string, rateId: string, observe?: 'body', reportProgress?: boolean): Observable<DioProductRateDeposit>;
    public getProductRateDeposit(brandId: string, productId: string, rateId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductRateDeposit>>;
    public getProductRateDeposit(brandId: string, productId: string, rateId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductRateDeposit>>;
    public getProductRateDeposit(brandId: string, productId: string, rateId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling getProductRateDeposit.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getProductRateDeposit.');
        }

        if (rateId === null || rateId === undefined) {
            throw new Error('Required parameter rateId was null or undefined when calling getProductRateDeposit.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<DioProductRateDeposit>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/deposit-rate/${encodeURIComponent(String(rateId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a single Product Lending Rate
     * Returns a single product rate entry
     * @param brandId 
     * @param productId 
     * @param rateId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductRateLending(brandId: string, productId: string, rateId: string, observe?: 'body', reportProgress?: boolean): Observable<DioProductRateLending>;
    public getProductRateLending(brandId: string, productId: string, rateId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductRateLending>>;
    public getProductRateLending(brandId: string, productId: string, rateId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductRateLending>>;
    public getProductRateLending(brandId: string, productId: string, rateId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling getProductRateLending.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getProductRateLending.');
        }

        if (rateId === null || rateId === undefined) {
            throw new Error('Required parameter rateId was null or undefined when calling getProductRateLending.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<DioProductRateLending>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/lending-rate/${encodeURIComponent(String(rateId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List Bundles assigned to Product
     * List Bundles assigned to Product
     * @param brandId 
     * @param productId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listBundlesForProduct(brandId: string, productId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DioProductBundle>>;
    public listBundlesForProduct(brandId: string, productId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DioProductBundle>>>;
    public listBundlesForProduct(brandId: string, productId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DioProductBundle>>>;
    public listBundlesForProduct(brandId: string, productId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling listBundlesForProduct.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling listBundlesForProduct.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<DioProductBundle>>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/bundle`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Product Constraints
     * List all Product Constraints
     * @param brandId 
     * @param productId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listProductConstraints(brandId: string, productId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DioProductConstraint>>;
    public listProductConstraints(brandId: string, productId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DioProductConstraint>>>;
    public listProductConstraints(brandId: string, productId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DioProductConstraint>>>;
    public listProductConstraints(brandId: string, productId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling listProductConstraints.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling listProductConstraints.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<DioProductConstraint>>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/constraint`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Product Eligibilitys
     * List all Product Eligibilitys
     * @param brandId 
     * @param productId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listProductEligibilitys(brandId: string, productId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DioProductEligibility>>;
    public listProductEligibilitys(brandId: string, productId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DioProductEligibility>>>;
    public listProductEligibilitys(brandId: string, productId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DioProductEligibility>>>;
    public listProductEligibilitys(brandId: string, productId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling listProductEligibilitys.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling listProductEligibilitys.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<DioProductEligibility>>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/eligibility`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Product Features
     * List all Product Features
     * @param brandId 
     * @param productId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listProductFeatures(brandId: string, productId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DioProductFeature>>;
    public listProductFeatures(brandId: string, productId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DioProductFeature>>>;
    public listProductFeatures(brandId: string, productId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DioProductFeature>>>;
    public listProductFeatures(brandId: string, productId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling listProductFeatures.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling listProductFeatures.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<DioProductFeature>>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/feature`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Product Fees
     * List all Product Fees
     * @param brandId 
     * @param productId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listProductFees(brandId: string, productId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DioProductFee>>;
    public listProductFees(brandId: string, productId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DioProductFee>>>;
    public listProductFees(brandId: string, productId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DioProductFee>>>;
    public listProductFees(brandId: string, productId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling listProductFees.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling listProductFees.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<DioProductFee>>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/fee`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Product Deposit Rates
     * List all Product Rates
     * @param brandId 
     * @param productId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listProductRateDeposits(brandId: string, productId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DioProductRateDeposit>>;
    public listProductRateDeposits(brandId: string, productId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DioProductRateDeposit>>>;
    public listProductRateDeposits(brandId: string, productId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DioProductRateDeposit>>>;
    public listProductRateDeposits(brandId: string, productId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling listProductRateDeposits.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling listProductRateDeposits.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<DioProductRateDeposit>>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/deposit-rate`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Product Lending Rates
     * List all Product Rates
     * @param brandId 
     * @param productId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listProductRateLendings(brandId: string, productId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DioProductRateLending>>;
    public listProductRateLendings(brandId: string, productId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DioProductRateLending>>>;
    public listProductRateLendings(brandId: string, productId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DioProductRateLending>>>;
    public listProductRateLendings(brandId: string, productId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling listProductRateLendings.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling listProductRateLendings.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<DioProductRateLending>>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/lending-rate`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Products
     * List all Products
     * @param brandId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listProducts(brandId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DioProduct>>;
    public listProducts(brandId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DioProduct>>>;
    public listProducts(brandId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DioProduct>>>;
    public listProducts(brandId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling listProducts.');
        }

        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<DioProduct>>('get',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a single Product
     * Updates and Returns an existing Product
     * @param brandId 
     * @param productId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProduct(brandId: string, productId: string, body?: DioProduct, observe?: 'body', reportProgress?: boolean): Observable<DioProduct>;
    public updateProduct(brandId: string, productId: string, body?: DioProduct, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProduct>>;
    public updateProduct(brandId: string, productId: string, body?: DioProduct, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProduct>>;
    public updateProduct(brandId: string, productId: string, body?: DioProduct, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling updateProduct.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling updateProduct.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProduct>('put',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a single Product Constraint
     * Updates and Returns an existing Product Constraint
     * @param brandId 
     * @param productId 
     * @param constraintId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductConstraint(brandId: string, productId: string, constraintId: string, body?: DioProductConstraint, observe?: 'body', reportProgress?: boolean): Observable<DioProductConstraint>;
    public updateProductConstraint(brandId: string, productId: string, constraintId: string, body?: DioProductConstraint, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductConstraint>>;
    public updateProductConstraint(brandId: string, productId: string, constraintId: string, body?: DioProductConstraint, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductConstraint>>;
    public updateProductConstraint(brandId: string, productId: string, constraintId: string, body?: DioProductConstraint, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling updateProductConstraint.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling updateProductConstraint.');
        }

        if (constraintId === null || constraintId === undefined) {
            throw new Error('Required parameter constraintId was null or undefined when calling updateProductConstraint.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProductConstraint>('put',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/constraint/${encodeURIComponent(String(constraintId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a single Product Eligibility
     * Updates and Returns an existing Product Eligibility
     * @param brandId 
     * @param productId 
     * @param eligibilityId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductEligibility(brandId: string, productId: string, eligibilityId: string, body?: DioProductEligibility, observe?: 'body', reportProgress?: boolean): Observable<DioProductEligibility>;
    public updateProductEligibility(brandId: string, productId: string, eligibilityId: string, body?: DioProductEligibility, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductEligibility>>;
    public updateProductEligibility(brandId: string, productId: string, eligibilityId: string, body?: DioProductEligibility, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductEligibility>>;
    public updateProductEligibility(brandId: string, productId: string, eligibilityId: string, body?: DioProductEligibility, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling updateProductEligibility.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling updateProductEligibility.');
        }

        if (eligibilityId === null || eligibilityId === undefined) {
            throw new Error('Required parameter eligibilityId was null or undefined when calling updateProductEligibility.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProductEligibility>('put',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/eligibility/${encodeURIComponent(String(eligibilityId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a single Product Feature
     * Updates and Returns an existing Product Feature
     * @param brandId 
     * @param productId 
     * @param featureId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductFeature(brandId: string, productId: string, featureId: string, body?: DioProductFeature, observe?: 'body', reportProgress?: boolean): Observable<DioProductFeature>;
    public updateProductFeature(brandId: string, productId: string, featureId: string, body?: DioProductFeature, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductFeature>>;
    public updateProductFeature(brandId: string, productId: string, featureId: string, body?: DioProductFeature, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductFeature>>;
    public updateProductFeature(brandId: string, productId: string, featureId: string, body?: DioProductFeature, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling updateProductFeature.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling updateProductFeature.');
        }

        if (featureId === null || featureId === undefined) {
            throw new Error('Required parameter featureId was null or undefined when calling updateProductFeature.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProductFeature>('put',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/feature/${encodeURIComponent(String(featureId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a single Product Fee
     * Updates and Returns an existing Product Fee
     * @param brandId 
     * @param productId 
     * @param feeId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductFee(brandId: string, productId: string, feeId: string, body?: DioProductFee, observe?: 'body', reportProgress?: boolean): Observable<DioProductFee>;
    public updateProductFee(brandId: string, productId: string, feeId: string, body?: DioProductFee, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductFee>>;
    public updateProductFee(brandId: string, productId: string, feeId: string, body?: DioProductFee, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductFee>>;
    public updateProductFee(brandId: string, productId: string, feeId: string, body?: DioProductFee, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling updateProductFee.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling updateProductFee.');
        }

        if (feeId === null || feeId === undefined) {
            throw new Error('Required parameter feeId was null or undefined when calling updateProductFee.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProductFee>('put',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/fee/${encodeURIComponent(String(feeId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a single Product Deposit Rate
     * Updates and Returns an existing Product Deposit Rate
     * @param brandId 
     * @param productId 
     * @param rateId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductRateDeposit(brandId: string, productId: string, rateId: string, body?: DioProductRateDeposit, observe?: 'body', reportProgress?: boolean): Observable<DioProductRateDeposit>;
    public updateProductRateDeposit(brandId: string, productId: string, rateId: string, body?: DioProductRateDeposit, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductRateDeposit>>;
    public updateProductRateDeposit(brandId: string, productId: string, rateId: string, body?: DioProductRateDeposit, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductRateDeposit>>;
    public updateProductRateDeposit(brandId: string, productId: string, rateId: string, body?: DioProductRateDeposit, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling updateProductRateDeposit.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling updateProductRateDeposit.');
        }

        if (rateId === null || rateId === undefined) {
            throw new Error('Required parameter rateId was null or undefined when calling updateProductRateDeposit.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProductRateDeposit>('put',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/deposit-rate/${encodeURIComponent(String(rateId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a single Product Lending Rate
     * Updates and Returns an existing Product Lending Rate
     * @param brandId 
     * @param productId 
     * @param rateId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductRateLending(brandId: string, productId: string, rateId: string, body?: DioProductRateLending, observe?: 'body', reportProgress?: boolean): Observable<DioProductRateLending>;
    public updateProductRateLending(brandId: string, productId: string, rateId: string, body?: DioProductRateLending, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DioProductRateLending>>;
    public updateProductRateLending(brandId: string, productId: string, rateId: string, body?: DioProductRateLending, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DioProductRateLending>>;
    public updateProductRateLending(brandId: string, productId: string, rateId: string, body?: DioProductRateLending, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (brandId === null || brandId === undefined) {
            throw new Error('Required parameter brandId was null or undefined when calling updateProductRateLending.');
        }

        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling updateProductRateLending.');
        }

        if (rateId === null || rateId === undefined) {
            throw new Error('Required parameter rateId was null or undefined when calling updateProductRateLending.');
        }


        let headers = this.defaultHeaders;

        // authentication (deepthought_auth) required
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DioProductRateLending>('put',`${this.basePath}/v1/brand/${encodeURIComponent(String(brandId))}/product/${encodeURIComponent(String(productId))}/lending-rate/${encodeURIComponent(String(rateId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
